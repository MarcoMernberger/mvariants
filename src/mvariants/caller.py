#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""caller.py: Contains different wrapper for variant caller."""

from pypipegraph import Job
from mvariants import __version__
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Optional, Callable, List, Dict, Tuple, Any, Union
from mbf.align.lanes import AlignedSample
from .base import OptionHandler, GATK
from .pre_process import SamtoolsmPileupSingleFile, _PreProcessor, GATKPreprocessor
from .util import download_file_and_targz, parse_vcf2
from pandas import DataFrame
import subprocess
import pypipegraph as ppg

__author__ = "Marco Mernberger"
__copyright__ = "Copyright (c) 2020 Marco Mernberger"
__license__ = "mit"


class _Caller(ABC):
    """
    This is a base class for variant caller.

    Caller defines some basic attributes that need to be implemented in
    every caller sub class.

    Parameters
    ----------
    input_samples : List[List[AlignedSample]]
        List of lists of matched tumor-normal samples. The second list may be empty.
    caller : Caller
        Variant caller to use.

    Parameters
    ----------
    instance_name : str
        Name that is unique for a specific analysis.
    preprocessor : Optional[PreProcessor]
        Preprocessor for the variant calling.
    """

    def __init__(
        self,
        instance_name: str,
        preprocessor: Optional[_PreProcessor],
        **kwargs,
    ):
        """_Caller constructor, see class documentation for details."""
        super().__init__()
        self._instance_name = instance_name
        self._preprocessor = preprocessor

    @property
    def options(self) -> Dict:
        """Returns a dictionary of parameter-values for the variant caller."""
        return self._options

    @options.setter
    def options(self, options: Dict[str, str]) -> None:
        """Setter for the options attribute."""
        self._options = options

    @property
    def optionhandler(self):
        """Returns the callers option handler."""
        return self._optionhandler

    @optionhandler.setter
    def optionhandler(self, optionhandler: OptionHandler) -> None:
        """Setter for the aptionhandler attribute."""
        self._optionhandler = optionhandler

    @property
    def preprocessor(self) -> Optional[_PreProcessor]:
        """Returns the callers preprocessor."""
        return self._preprocessor

    @preprocessor.setter
    def preprocessor(self, preprocessor: _PreProcessor) -> None:
        """Setter for the preprocessor attribute."""
        self._preprocessor = preprocessor

    @property
    def instance_name(self) -> str:
        """Returns a unique id for the specific caller and its options."""
        return self._instance_name

    @instance_name.setter
    def instance_name(self, name) -> None:
        """Setter for the instance_name attribute."""
        self._instance_name = name

    def print_help(self) -> None:
        """Prints help string for the caller options."""
        self.optionhandler.print_help()

    @abstractmethod
    def run(self) -> Callable:
        """
        Returns a callable that will run the actual mutation analysis.

        This returns a callable used for creating a Job that will run the
        analysis.

        Returns
        -------
        Callable
            A callable that runs the actual analysis.
        """
        pass  # pragma: no cover

    def get_dependencies(self) -> List[Job]:
        """
        Returns a list of dependencies for the pypipegraph.

        Returns a list of pypipegraph.Jobs that need to run before the actual
        variant calling.

        Returns
        -------
        List[Job]
            List of dependencies.
        """
        return [
            ppg.ParameterInvariant(
                f"{self.instance_name}", OptionHandler.options_as_list_str(self.options)
            ),
            ppg.FunctionInvariant(f"{self.instance_name}_runfunc", self.run),
        ]

    @abstractmethod
    def get_option_parser(self) -> Callable:
        """
        Returns an option_getter callable for the OptionHandler class.

        Returns a callable that returns the help string, a dictionary of allowed
        options and descriptions and a dictionary with default values.

        Returns
        -------
        Callable
            Callable for initialization of the OptionHandler of this caller.
        """
        pass  # pragma: no cover

    def result_to_df_parser(self) -> Callable:
        """
        Returns a parser for the result file generated by the variant calling.

        Returns a result file parser for the variant call result file, which
        typically should be a vcf file.

        Returns
        -------
        Callable
            A method that turns the varriant call output into a DataFrame.
        """
        return parse_vcf2

    def get_parameters(self) -> Dict[str, Any]:
        """
        Returns all run parameters.

        Returns a dictionary of run parameters with key, value pairs.

        Returns
        -------
        Dict
            dictionary of run parameters.
        """
        return self.options

    def get_cores_needed(self) -> int:
        """
        Returns the number of cores the GATK call will need.

        Implements the ExternalAlgorithm abstract method.

        Returns
        -------
        int
            [description]
        """
        return 1


class VarScan2(_Caller):
    """
    Wrapper for the VarScan2 variant caller.

    Wrapper for the VarScan2 caller, subclassing both mbf.externals.ExternalAlgorithm
    and _Caller. The ExternalAlgorithm takes care of version handling, while the
    _Caller class provides methods for variant analysis.
    VarScan2 can be initialized with a dictionary of options and a preprocessor
    that takes care of everything that needs to happen prior to the actual
    variant calling. If no preprocessor is provided, a default preprocessor
    using samtools is instantiated.

    Parameters
    ----------
    caller_type : str
        the type of analysis to be performed.
    preprocessor : _PreProcessor, optional
        Preprocessor for the variant calling, by default None.
    options : Optional[Dict[str, str]], optional
        Dictionary of parameter-values to be supplied to the GATK call.
    version : str, optional
        Version of the tool to be used, by default "_last_used".

    Raises
    ------
    ValueError
        Raises if an invalid caller_type is specified.
    """

    def __init__(
        self,
        caller_type: str,
        preprocessor: Optional[Union[_PreProcessor, str]] = "default",
        options: Dict[str, Any] = {},
        **kwargs,
    ) -> None:
        """VarScan2 constructor, see class documentation for details."""
        _instance_name = kwargs.get("instance_name", f"Varscan_{caller_type}")
        _preprocessor = preprocessor
        if _preprocessor == "default":
            # if no preprocessor is given, initialize a default samtools pileup
            _preprocessor = SamtoolsmPileupSingleFile(
                min_base_quality=options.get("--min-avg-qual", 15)
            )  # TODO: add Optionhandler
        super().__init__(
            instance_name=_instance_name,
            preprocessor=_preprocessor,
        )
        self.command = "varscan"
        self.valid_types = self.get_valid_types()
        if caller_type not in self.valid_types:
            raise ValueError(
                f"Accepted values for caller_type are Varscan commands: {self.valid_types}"
            )
        self.caller_type = caller_type
        self.optionhandler = OptionHandler(
            f"{self._instance_name}_optionhandler",
            self.get_option_parser([caller_type, "--help"]),
            warn="always",
            explicit=kwargs.get("explicit_options", True),
        )
        self._options = self.optionhandler.check_options(options)
        if len(self._options) == 0:
            self._options = self.optionhandler.default_parameter

    @property
    def name(self) -> str:
        """
        Getter for the name of the external method for version handling.

        Overrides the ExternalAlgorithm method.

        Returns
        -------
        str
            Name of the external method.
        """
        return "VarScan2"

    @property
    def multi_core(self) -> bool:
        """
        Returns False as VarScan cannot use multiple cores for a single call.

        Overrides the ExternalAlgorithm method.

        Returns
        -------
        bool
            Whether the external method can use multiple cores.
        """
        return False

    def build_cmd(
        self, output_directory: Optional[Path], ncores: int, arguments: List[str]
    ):
        """
        Returns a command as a list of strings to be passed to subprocess.

        Overrides the ExternalAlgorithm method. Constructs an executable
        command to be passed to subprocess. Output directory and ncores
        parameters are ignored, output directory is included in the option list.

        Parameters
        ----------
        output_directory : Optional[Path]
            Path of output directory.
        ncores : int
            Number of cores to be used.
        arguments : List[str]
            List of string arguments for the command call.

        Returns
        -------
        List[str]
            Command to subprocess as a list of strings.
        """
        return [self.command] + arguments

    def get_version(self) -> str:
        """Getter for the latest_version attribute."""
        out = subprocess.check_output([self.command])
        version = out.decode().split("\n")[0].replace("VarScan v", "")
        return version

    def __execute(self, command):
        """Calls a command via subprocess."""
        try:
            output = subprocess.check_output(command, stderr=subprocess.STDOUT).decode()
        except subprocess.CalledProcessError as exc:
            if exc.returncode == 1:
                output = exc.output.decode()
            else:
                raise
        return output

    def get_valid_types(self) -> Dict[str, str]:
        """
        Returns a dictionary of allowed caller_type values.

        Calls VarScan2 help and extracts the allowed caller options.

        Returns
        -------
        Dict[str, str]
            Dictionary of accepted caller_type values and descriptions.
        """
        output = self.__execute(self.build_cmd(None, None, ["--help"]))
        valid_types = {}
        for line in output.split("COMMANDS:")[1].strip().split("\n"):
            if line != "":
                x = line.strip().split("\t\t")
                valid_types[x[0].strip()] = x[1].strip()
        return valid_types

    def get_option_parser(self, arguments):
        """
        Returns an option_getter callable for the OptionHandler class.

        Overrides abstract method of _Caller. Returns a callable that returns
        the help string, a dictionary of allowed options and descriptions and
        a dictionary with default values inferred from the VarScan2 help.

        Returns
        -------
        Callable
            Callable for initialization of the OptionHandler of this caller.
        """

        def __init_options() -> Tuple[str, Dict[str, str], Dict[str, Any]]:
            command = self.build_cmd(None, None, arguments)
            help_str = self.__execute(command)
            allowed_options = {}
            default_values = {}
            for line in help_str.split("\n"):
                if "--" in line:
                    splits = line.strip().split()
                    allowed_options[splits[0]] = " ".join(splits[1:])
                    i = splits[-1].find("[")
                    if i == -1:
                        continue
                    arg = splits[-1][i + 1 : -1]
                    try:
                        arg = eval(arg)
                    except NameError:
                        pass
                    default_values[splits[0]] = arg
            if "--output-vcf" in allowed_options:
                default_values["--output-vcf"] = 1
            if "--output-snp" in default_values:
                del default_values["--output-snp"]
            if "--output-indel" in default_values:
                del default_values["--output-indel"]

            return help_str, allowed_options, default_values

        return __init_options

    def __repr__(self) -> str:
        return f"VarScan({self.caller_type}, {self.instance_name}, {self.preprocessor.__repr__()}, {self.options})"

    def __str__(self) -> str:
        return f"VarScan(caller_type = {self.caller_type}, instance_name = {self.instance_name}, preprocessor = {self.preprocessor.__str__()}, options = {self.options})"

    def run(self) -> Callable:
        """
        Returns a callable that will run the actual mutation analysis.

        Overrides the abstract _Caller method. This returns a callable used for creating a Job that will run the
        analysis.

        Returns
        -------
        Callable
            A callable that runs the actual analysis.
        """

        def call(
            input_files: List[List[AlignedSample]], output_file: Path, *args, **kwargs
        ):
            cmd_call = [self.caller_type]
            cmd_call.extend([str(posixpath) for posixpath in input_files])
            cmd_call.append(str(output_file))
            if self.caller_type == "somatic" or self.caller_type == "copynumber":
                if len(input_files) != 2:
                    raise ValueError(
                        f"Selected analysis {self.caller_type} needs a list of matched pileup files, got {input_files, type(input_files)}"
                    )
                cmd_call.extend(
                    [
                        "--output-snp",
                        str(output_file.parent / (output_file.stem + ".snp")),
                    ]
                )
                cmd_call.extend(
                    [
                        "--output-indel",
                        str(output_file.parent / (output_file.stem + ".indel")),
                    ]
                )
            cmd_call.extend(self.optionhandler.options_as_list_str(self.options))
            cmd_call = self.build_cmd(
                output_directory=output_file.parent,
                ncores=self.get_cores_needed(),
                arguments=cmd_call,
            )
            output_file.parent.mkdir(parents=True, exist_ok=True)
            with Path(str(output_file) + ".varscan.log").open(
                "w"
            ) as stderr, output_file.open("w") as outp:
                stderr.write(" ".join(cmd_call) + "\n")
                print(" ".join(cmd_call))
                raise ValueError()
                try:
                    p2 = subprocess.Popen(cmd_call, stdout=outp, stderr=stderr)
                    p2.communicate()
                except subprocess.CalledProcessError:
                    print(f"Call failed : {' '.join(cmd_call)}")
                    raise
            if self.caller_type in ["somatic"]:
                with Path(output_file).open("w") as outp:
                    outp.write(
                        f'Results in \n{str(output_file.parent / (output_file.stem + ".snp"))}\n{str(output_file.parent / (output_file.stem + ".indel"))}'
                    )

        if self.preprocessor is not None:
            modifier = self.preprocessor.run_modifier()
            call = modifier(call)
        return call

    def get_cores_needed(self) -> int:
        """
        Returns the number of cores the GATK call will need.

        Overrides the ExternalAlgorithm abstract method.

        Returns
        -------
        int
            Only use a single core per variant call.
        """
        return 1

    def read_somatic(self, inputfile: str) -> DataFrame:
        """
        Reader function for VarScan2 alternative output format.

        Reader function that can read the result files of tumor-normal matched
        sample calling, which produces two separate outputs.

        Parameters
        ----------
        inputfile : str
            The input file to be read.

        Returns
        -------
        DataFrame
            Dataframe containing the variant calls.
        """
        outfile = Path(inputfile)
        snp_file = str(outfile.parent / (outfile.stem + ".snp.vcf"))
        indel_file = str(outfile.parent / (outfile.stem + ".indel.vcf"))
        df = parse_vcf2(snp_file, indel_file)
        return df

    def result_to_df_parser(self) -> Callable:
        """
        Returns a parser for the result file generated by the variant calling.

        Overrides the _Caller method. Returns either the standard vcf parser or
        read_somatioc parser. based on the caller options chosen.

        Returns
        -------
        Callable
            A method that turns the varriant call output into a DataFrame.
        """
        if self.caller_type == "somatic":
            return self.read_somatic
        else:
            return parse_vcf2


class Mutect2(GATK, _Caller):
    """
    Wrapper for the Mutect2 variant caller.

    Wrapper for the Mutect2 caller, subclassing both mbf.externals.ExternalAlgorithm
    and _Caller. The ExternalAlgorithm takes care of version handling, while the
    _Caller class provides methods for variant analysis.
    Mutect2 can be initialized with a dictionary of options and a preprocessor
    that takes care of everything that needs to happen prior to the actual
    variant calling. If no preprocessor is provided, a default preprocessor
    is instantiated with a genome that must be supplied instead.

    Parameters
    ----------
    preprocessor : _PreProcessor, optional
        PreProcessor of Mutect2, by default None. If this is None, then a
        genome must be specified.
    options : Optional[Dict[str, str]], optional
        Dictionary of parameter-values to be supplied to the Mutect2 call.

    Raises
    ------
    ValueError
        Raises if no genome or preprocessor is supplied.
    """

    def __init__(
        self,
        preprocessor: Optional[_PreProcessor] = None,
        options: Dict[str, Any] = {},
        **kwargs,
    ):
        """Mutect2 constructor, see class documentation for details."""
        _preprocessor = preprocessor
        if _preprocessor is None:
            genome = kwargs.get("genome", None)
            if genome is None:
                raise ValueError(
                    "Mutect2 can only be instantiated with a PreProcessor or a genome supplied."
                )
            else:
                _preprocessor = GATKPreprocessor(
                    genome=genome, instance_name="GATKPreprocess_default"
                )
        _instance_name = kwargs.get("instance_name", "Mutect2")
        super().__init__(
            tool="Mutect2",
            options=options,
            instance_name=_instance_name,
            preprocessor=_preprocessor,
            **kwargs,
        )

    @property
    def multi_core(self):
        """
        Returns wether Mutect2 can use multiple cores.

        Overrides the ExternalAlgorithm method.
        """
        return True

    def __repr__(self) -> str:
        return f"Mutect2({self.preprocessor.__repr__()})"  # , {self.options}

    def __str__(self) -> str:
        return f"Mutect2(preprocessor = {self.preprocessor.__str__()}, options = {self.options})"

    def _option_parser_modifier(self):
        """Modifies the default GATK get_option_parser callable."""

        def wrapper(func):
            def parse():
                help_str, allowed_options, default_values = func()
                default_values["--smith-waterman"] = "FASTEST_AVAILABLE"
                del default_values["--gcs-project-for-requester-pays"]
                return help_str, allowed_options, default_values

            return parse

        return wrapper

    def run(self) -> Callable:
        """
        Returns a callable that will run the actual mutation analysis.

        Overrides the abstract _Caller method. This returns a callable used for
        creating a Job that will run the specific Mutect2 analysis.

        Returns
        -------
        Callable
            A callable that runs the actual analysis.
        """

        def call(
            input_samples: List[List[AlignedSample]], output_file: Path, *args, **kwargs
        ):
            if len(args) > 0:
                # the preprocessor run_modifier will take care of this
                gatk_genome_file = args[0]
            else:
                gatk_genome_file = input_samples[0].genome.find_file("genome.fasta")

            output_unfiltered = output_file.parent / (
                output_file.stem + ".unfiltered.vcf"
            )
            output_file.parent.mkdir(exist_ok=True, parents=True)

            if len(input_samples[1]) == 0:
                raise ValueError(
                    "Mutect2 currently does not support single sample calling."
                )
            else:
                cmd_arguments = []
            for input_sample in input_samples[0]:
                # this would be tumor
                cmd_arguments.extend(
                    [
                        "-I",
                        str(input_sample.bam_filename),
                        "-tumor",
                        input_sample.name,
                    ]
                )
            for input_sample in input_samples[1]:
                cmd_arguments.extend(
                    [
                        "-I",
                        str(input_sample.bam_filename),
                        "-normal",
                        input_sample.name,
                    ]
                )
            cmd_arguments.extend(
                [
                    "-O",
                    str(output_unfiltered),
                    "-R",
                    str(gatk_genome_file),
                ]
            )
            cmd_arguments.extend(OptionHandler.options_as_list_str(self.options))
            cmd = self.build_cmd(
                output_unfiltered.parent, self.get_cores_needed(), cmd_arguments
            )
            stderr = Path(str(output_file) + ".mutect2.log").open("w")
            stderr.write(" ".join(cmd) + "\n")
            try:
                subprocess.check_call(cmd, stderr=stderr)
            except subprocess.CalledProcessError:
                print(" ".join(cmd))
                raise
            stderr.write("-----Filtering------\n")
            try:
                cmd_filter = self.filter_mutect(
                    output_unfiltered, gatk_genome_file, output_file
                )
                subprocess.check_call(cmd_filter, stderr=stderr)
            except subprocess.CalledProcessError:
                print(" ".join(cmd_filter))
                raise
            stderr.close()

        if self.preprocessor is not None:
            modifier = self.preprocessor.run_modifier()
            call = modifier(call)
        return call

    def filter_mutect(
        self, infile: Path, gatk_genome_file: Path, output_file: Path
    ) -> List[str]:
        """
        Builds a command for filtering Mutect2 results.

        Builds a command that calls GATK to perform a filtering for the Mutect2
        analysis, since Mutect2 by default writes any call to the result vcf,
        even non-significant ones. This command is passed to subprocess.

        Parameters
        ----------
        infile : Path
            Path to the unfiltered vcf file.
        gatk_genome_file : Path
            Path to the GATK compliant genome.
        output_file : Path
            Path to filtered output vcf.

        Returns
        -------
        List[str]
            List of strings to be passed to subprocess.
        """
        cmd_arguments = [
            "-V",
            str(infile),
            "-R",
            str(gatk_genome_file),
            "-O",
            str(output_file),
        ]
        cmd = self.build_cmd(None, 1, cmd_arguments)
        cmd[1] = "FilterMutectCalls"
        return cmd
